A real-world vulnerability in `htmldoc`
=======================================

`htmldoc` is a utility to convert HTML documents to PDF and other target
formats. A larger number of vulnerabilities have been found in the tool over
time, not too long ago a very simple stack buffer overflow which we will
exploit here.

The vulnerability was handled in [bsc#1194487][1], CVE-2021-43579.

[1]: https://bugzilla.suse.com/show_bug.cgi?id=1194487

The issue was found in the parsing of BMP image file data which can be
referenced in HTML input sources. The issue was [reported][2] upstream.

[2]: https://github.com/michaelrsweet/htmldoc/issues/453

In the report we can also find a `poc.zip` file that demonstrates the issue.

Building the Vulnerable Version
-------------------------------

The issue was fixed in version `v1.9.13`, thus we need to obtain one version
before that.

```sh
$ git clone https://github.com/michaelrsweet/htmldoc.git
$ cd htmldoc
$ git checkout v1.9.12
```

For building we require a number of devel packages. For some reason building
without GUI support is broken, so we have to deal with all that GUI stuff:

```sh
$ sudo zypper in fltk-devel libjpeg8-devel libpng16-devel
```

Apply the following patch to `Makedefs.in` to get verbose compiler
invocations, otherwise we won't see what is going on:

```
diff --git a/Makedefs.in b/Makedefs.in
index 596e4b0..210df57 100644
--- a/Makedefs.in
+++ b/Makedefs.in
@@ -86,7 +86,9 @@ WARNINGS      =       @WARNINGS@
 .SUFFIXES:     .a .c .cxx .h .o
 .c.o:
        echo Compiling $<...
+       echo $(CC) $(CPPFLAGS) $(CFLAGS) -c $<
        $(CC) $(CPPFLAGS) $(CFLAGS) -c $<
 .cxx.o:
        echo Compiling $<...
+       echo $(CXX) $(CPPFLAGS) $(CXXFLAGS) -c $<
        $(CXX) $(CPPFLAGS) $(CXXFLAGS) -c $<
```

Also remove the two hard coded CFLAGS settings mentioning `_FORTIFY_SOURCE` in
"configure.ac":

```
diff --git a/configure.ac b/configure.ac
index 82315b8..c84cba2 100644
--- a/configure.ac
+++ b/configure.ac
@@ -341,8 +341,8 @@ AS_IF([test -n "$GXX"], [
     ], [
        # Otherwise use the Fortify enhancements to catch any unbounded
        # string operations...
-       CFLAGS="$CFLAGS -D_FORTIFY_SOURCE=2"
-       CXXFLAGS="$CXXFLAGS -D_FORTIFY_SOURCE=2"
+       CFLAGS="$CFLAGS"
+       CXXFLAGS="$CXXFLAGS"
     ])

     dnl Set optimization flags...
```

Now let's actually build:

```sh
$ autoreconf
$ ./configure --with-gui
$ make
```

Finally mark the resulting executable with `execstack`:

    execstack -s ./htmldoc/htmldoc

Testing the Proof of Concept (PoC)
----------------------------------

In the example's subdirectory `poc` you can find the PoC files provided by the
upstream reporter. Let's first check whether this crashes the program as
expected.  Before doing so inspect the PoC files, though. We don't want to
execute potential exploit code blindly. Look at the HTML file and at `xxd
poc.bmp` to better understand the content of the PoC.

Finally test the PoC works like this:

```sh
$ ./htmldoc/htmldoc -f poc.pdf /path/to/poc.html
ERR005: Unable to open psglyphs data file!
ERR005: Unable to open character set file iso-8859-1!
Segmentation fault (core dumped)
```

You should see similar output to above that shows that process aborts with a
segmentation fault.

Investigating the Vulnerable Function
-------------------------------------

The problem is found in the function `image_load_bmp()` when the logic
attempts to fill the `colormap` buffer, which is one kilobyte in size.
What the vulnerable function attempts to do is parsing the BMP input file.
Find a description of the BMP header binary format [here][3] or [here][4].

[3]: http://www.ece.ualberta.ca/~elliott/ee552/studentAppNotes/2003_w/misc/bmp_file_format/bmp_file_format.htm
[4]: https://cdn.hackaday.io/files/274271173436768/Simplified%20Windows%20BMP%20Bitmap%20File%20Format%20Specification.htm

The file `bmp.txt` which accompanies this example also gives a short overview
of the individual bytes that are part of the `poc.bmp`. From all this
information we can learn that the relevant bytes of the BMP header to trigger
this exploit are the first 54 bytes, which we can extract from the `poc.bmp`
file as follows:

```sh
$ dd if=./poc/poc.bmp of=header.bmp bs=1 count=54
```

For creating a fully functional exploit we just need to concatenate this
`header.bmp` and the actual exploit buffer that you can create using the
`gen_exploit.py` helper script.

Finding out the Return Address
------------------------------

Invoke a shell using

    setarch `uname -m` -R /bin/bash

and run the PoC against htmldoc as described above, but while running
`htmldoc` in gdb. Set a breakpoint in `image_load_bmp()` and get the address
for the `colormap` buffer.

When looking at the context more closely you will notice special circumstances
(see below). The buffers found in `image_load()` are also relevant for the
overflow. The `image_t key` stack variable is also over one kilobyte in size.
Thus over two kilobytes of data can and need to be supplied before we will
reach the actual return address of the stack frame.

Special Circumstances of this Vulnerability
-------------------------------------------

This program has a number of specialities that are worth noting:

- The project has a mixture of C and C++ code. The vulnerability is in a C++
  unit. The code present there isn't really using much C++ features though, it
  looks mostly like C. Probably is was turned into a C++ unit for a few
  features but otherwise left untouched.
- `gdb` tells us (via `info frame`) that the vulnerable function's stack frame
  is *inlined* into the parent function's frame. This results from an
  optimization the compiler has performed, the two functions have been merged,
  so to say. Thus the stack variables of both functions have to be considered
  for the same stack frame.
- Due to this more than 2 Kilobytes of stack data needs to be overwritten to
  reach the return address.
- The problematic use of the `fread()` function does not impose any limits
  regarding terminators thus an attacker does not have to worry which kind of
  data the exploit contains.
- A number of pointer parameters that are also present in the vulnerable
  function's context are placed in registers, which is important, because
  otherwise dereferencing them (after overwriting them) would break the
  exploit. Especially note the `image_t *img` pointer parameter in this regard.

Creating a Fully Working Exploit
--------------------------------

From all information gathered so far create an exploit buffer using the
`gen_exploit.py` script. Concatenate the relevant header part of the BMP image
and the exploit buffer to obtain a crafted BMP:

    $ cat header.bmp doc_exploit.bin >exploit.bmp

You now need to create a copy of the `poc.html` named `exploit.html` and
adjust the BMP include in it to include the `exploit.bmp` instead.

Now you can feed the `exploit.html` to htmldoc and test with different return
addresses in the exploit buffer until the shell execution works as intended.

Exercises
---------

- Look at the vulnerable BMP parsing code in htmldoc in more detail. What
  would you say about the code quality? What could be improved?
- Looking at the properties of this stack buffer overflow would you say it is
  good to exploit? How much degree of freedom does an attacker have?
